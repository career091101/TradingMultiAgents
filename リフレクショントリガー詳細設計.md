# リフレクショントリガー詳細設計書

## 1. 概要

リフレクション（振り返り）機能は、TradingAgents2の学習能力の中核を担う機能です。本設計書では、いつ、どのような条件で、どのレベルのリフレクションを実行するかを明確に定義します。

## 2. リフレクションレベルの定義

### 2.1 レベル構成

```python
from enum import Enum

class ReflectionLevel(Enum):
    """リフレクションのレベル定義"""
    IMMEDIATE = "immediate"      # 即時振り返り（取引直後）
    DAILY = "daily"             # 日次振り返り
    WEEKLY = "weekly"           # 週次振り返り
    MONTHLY = "monthly"         # 月次振り返り
    POSITION_CLOSE = "position" # ポジションクローズ時
    MILESTONE = "milestone"     # マイルストーン達成時
    SYSTEM = "system"           # システム全体振り返り
```

### 2.2 各レベルの詳細

| レベル | 実行タイミング | 対象 | 目的 |
|-------|--------------|------|------|
| IMMEDIATE | 取引実行直後 | 取引に関わった全エージェント | 判断プロセスの記録と即時フィードバック |
| DAILY | 毎日の市場クローズ後 | 全エージェント | 1日の判断と結果の総括 |
| WEEKLY | 毎週金曜日のクローズ後 | 全エージェント + システム | 週間パフォーマンスの分析 |
| MONTHLY | 月末 | システム全体 | 戦略の有効性評価と調整 |
| POSITION_CLOSE | ポジション決済時 | 取引関連エージェント | 個別取引の成功/失敗分析 |
| MILESTONE | 特定条件達成時 | システム全体 | 重要イベントからの学習 |
| SYSTEM | 四半期ごと | システム全体 | 包括的なシステム評価 |

## 3. トリガー条件の詳細設計

### 3.1 ReflectionTriggerクラス

```python
class ReflectionTrigger:
    """リフレクショントリガーの管理"""
    
    def __init__(self, config: ReflectionConfig):
        self.config = config
        self.event_history = EventHistory()
        self.performance_tracker = PerformanceTracker()
        self.schedule = ReflectionSchedule()
        
    def should_trigger(self, event: TradingEvent) -> List[ReflectionTask]:
        """トリガー条件の評価"""
        triggered_tasks = []
        
        # 1. イベントベーストリガー
        if event_tasks := self._check_event_triggers(event):
            triggered_tasks.extend(event_tasks)
            
        # 2. 時間ベーストリガー
        if time_tasks := self._check_time_triggers(event.timestamp):
            triggered_tasks.extend(time_tasks)
            
        # 3. パフォーマンスベーストリガー
        if perf_tasks := self._check_performance_triggers():
            triggered_tasks.extend(perf_tasks)
            
        # 4. 閾値ベーストリガー
        if threshold_tasks := self._check_threshold_triggers():
            triggered_tasks.extend(threshold_tasks)
            
        return triggered_tasks
```

### 3.2 イベントベーストリガー

```python
class EventBasedTriggers:
    """イベントに基づくトリガー条件"""
    
    def check_triggers(self, event: TradingEvent) -> List[ReflectionTask]:
        triggers = []
        
        # 取引実行イベント
        if isinstance(event, TradeExecutedEvent):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.TRADE_AGENTS,
                context=self._create_trade_context(event)
            ))
            
        # ポジションクローズイベント
        elif isinstance(event, PositionClosedEvent):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.POSITION_CLOSE,
                scope=ReflectionScope.POSITION_LIFECYCLE,
                context=self._create_position_context(event)
            ))
            
        # 大幅な損失イベント
        elif isinstance(event, SignificantLossEvent):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.RISK_ANALYSIS,
                priority=Priority.HIGH,
                context=self._create_loss_context(event)
            ))
            
        # ストップロス発動
        elif isinstance(event, StopLossTriggeredEvent):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.RISK_MANAGEMENT,
                priority=Priority.HIGH,
                context=self._create_stoploss_context(event)
            ))
            
        return triggers
```

### 3.3 時間ベーストリガー

```python
class TimeBasedTriggers:
    """時間に基づくトリガー条件"""
    
    def __init__(self, timezone: str = "UTC"):
        self.timezone = pytz.timezone(timezone)
        self.last_triggers = {}
        
    def check_triggers(self, current_time: datetime) -> List[ReflectionTask]:
        triggers = []
        local_time = current_time.astimezone(self.timezone)
        
        # 日次トリガー（市場クローズ後）
        if self._is_market_close(local_time) and self._should_trigger_daily(local_time):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.DAILY,
                scope=ReflectionScope.ALL_AGENTS,
                scheduled_time=self._get_daily_reflection_time(local_time)
            ))
            
        # 週次トリガー（金曜日のクローズ後）
        if local_time.weekday() == 4 and self._is_market_close(local_time):
            if self._should_trigger_weekly(local_time):
                triggers.append(ReflectionTask(
                    level=ReflectionLevel.WEEKLY,
                    scope=ReflectionScope.SYSTEM_WIDE,
                    scheduled_time=self._get_weekly_reflection_time(local_time)
                ))
                
        # 月次トリガー（月末）
        if self._is_month_end(local_time) and self._should_trigger_monthly(local_time):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.MONTHLY,
                scope=ReflectionScope.STRATEGIC_REVIEW,
                scheduled_time=self._get_monthly_reflection_time(local_time)
            ))
            
        # 四半期トリガー
        if self._is_quarter_end(local_time) and self._should_trigger_quarterly(local_time):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.SYSTEM,
                scope=ReflectionScope.COMPREHENSIVE_REVIEW,
                scheduled_time=self._get_quarterly_reflection_time(local_time)
            ))
            
        return triggers
```

### 3.4 パフォーマンスベーストリガー

```python
class PerformanceBasedTriggers:
    """パフォーマンスに基づくトリガー条件"""
    
    def __init__(self, config: PerformanceTriggerConfig):
        self.config = config
        self.metrics_monitor = MetricsMonitor()
        
    def check_triggers(self) -> List[ReflectionTask]:
        triggers = []
        current_metrics = self.metrics_monitor.get_current_metrics()
        
        # 連続損失トリガー
        if current_metrics.consecutive_losses >= self.config.max_consecutive_losses:
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.STRATEGY_REVIEW,
                priority=Priority.CRITICAL,
                reason="Consecutive losses threshold exceeded",
                context={
                    "consecutive_losses": current_metrics.consecutive_losses,
                    "total_loss": current_metrics.recent_loss_amount
                }
            ))
            
        # ドローダウン閾値トリガー
        if current_metrics.current_drawdown > self.config.max_drawdown_threshold:
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.RISK_REASSESSMENT,
                priority=Priority.HIGH,
                reason="Maximum drawdown threshold exceeded",
                context={
                    "current_drawdown": current_metrics.current_drawdown,
                    "drawdown_duration": current_metrics.drawdown_duration
                }
            ))
            
        # 異常リターントリガー（正負両方）
        if abs(current_metrics.daily_return) > self.config.abnormal_return_threshold:
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.ANOMALY_ANALYSIS,
                priority=Priority.MEDIUM,
                reason="Abnormal daily return detected",
                context={
                    "daily_return": current_metrics.daily_return,
                    "market_return": current_metrics.market_return,
                    "positions": current_metrics.current_positions
                }
            ))
            
        # パフォーマンス改善トリガー
        if self._detect_performance_improvement(current_metrics):
            triggers.append(ReflectionTask(
                level=ReflectionLevel.DAILY,
                scope=ReflectionScope.SUCCESS_ANALYSIS,
                priority=Priority.LOW,
                reason="Significant performance improvement detected",
                context=self._get_improvement_context(current_metrics)
            ))
            
        return triggers
```

### 3.5 閾値ベーストリガー

```python
class ThresholdBasedTriggers:
    """各種閾値に基づくトリガー条件"""
    
    def __init__(self, config: ThresholdConfig):
        self.config = config
        self.counters = TriggerCounters()
        
    def check_triggers(self) -> List[ReflectionTask]:
        triggers = []
        
        # 取引回数閾値
        if self.counters.trade_count >= self.config.trades_per_reflection:
            triggers.append(ReflectionTask(
                level=ReflectionLevel.MILESTONE,
                scope=ReflectionScope.TRADING_PATTERN,
                reason=f"Completed {self.counters.trade_count} trades",
                reset_counter=True
            ))
            
        # エージェント判断の不一致率
        if self._get_disagreement_rate() > self.config.disagreement_threshold:
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.AGENT_CONSENSUS,
                priority=Priority.MEDIUM,
                reason="High agent disagreement rate",
                context=self._get_disagreement_context()
            ))
            
        # 市場環境変化検出
        if self._detect_regime_change():
            triggers.append(ReflectionTask(
                level=ReflectionLevel.IMMEDIATE,
                scope=ReflectionScope.MARKET_REGIME,
                priority=Priority.HIGH,
                reason="Market regime change detected",
                context=self._get_regime_change_context()
            ))
            
        # メモリ使用量閾値（運用上の考慮）
        if self._get_memory_usage() > self.config.memory_threshold:
            triggers.append(ReflectionTask(
                level=ReflectionLevel.SYSTEM,
                scope=ReflectionScope.MEMORY_OPTIMIZATION,
                priority=Priority.MEDIUM,
                reason="Memory usage threshold exceeded",
                action="consolidate_memories"
            ))
            
        return triggers
```

## 4. リフレクション実行フロー

### 4.1 ReflectionExecutor

```python
class ReflectionExecutor:
    """リフレクションの実行管理"""
    
    def __init__(self, memory_store: MemoryStore, agent_registry: AgentRegistry):
        self.memory_store = memory_store
        self.agent_registry = agent_registry
        self.execution_queue = PriorityQueue()
        self.execution_history = ExecutionHistory()
        
    async def execute_reflection(self, task: ReflectionTask) -> ReflectionResult:
        """リフレクションタスクの実行"""
        
        # 1. 実行前検証
        if not self._validate_execution(task):
            return ReflectionResult.skipped(task, "Validation failed")
            
        # 2. 対象エージェントの特定
        target_agents = self._identify_target_agents(task)
        
        # 3. コンテキスト準備
        context = await self._prepare_context(task, target_agents)
        
        # 4. リフレクション実行
        reflection_outputs = {}
        for agent in target_agents:
            try:
                output = await agent.reflect(context)
                reflection_outputs[agent.name] = output
            except Exception as e:
                self._handle_reflection_error(agent, e)
                
        # 5. 結果の統合と学習
        integrated_result = await self._integrate_reflections(
            reflection_outputs, 
            task.level
        )
        
        # 6. メモリ更新
        await self._update_memories(integrated_result, task)
        
        # 7. フォローアップアクション
        follow_up_tasks = self._generate_follow_up_tasks(integrated_result)
        for follow_task in follow_up_tasks:
            self.execution_queue.put(follow_task)
            
        # 8. 実行履歴の記録
        self.execution_history.record(task, integrated_result)
        
        return integrated_result
```

### 4.2 リフレクションスケジューラー

```python
class ReflectionScheduler:
    """リフレクションのスケジューリング管理"""
    
    def __init__(self, config: SchedulerConfig):
        self.config = config
        self.trigger = ReflectionTrigger(config.trigger_config)
        self.executor = ReflectionExecutor()
        self.scheduler = AsyncIOScheduler()
        self._setup_scheduled_tasks()
        
    def _setup_scheduled_tasks(self):
        """定期実行タスクの設定"""
        
        # 日次リフレクション
        self.scheduler.add_job(
            self._daily_reflection,
            trigger='cron',
            hour=self.config.daily_reflection_hour,
            minute=0,
            timezone=self.config.timezone
        )
        
        # 週次リフレクション
        self.scheduler.add_job(
            self._weekly_reflection,
            trigger='cron',
            day_of_week='fri',
            hour=self.config.weekly_reflection_hour,
            minute=0,
            timezone=self.config.timezone
        )
        
        # 月次リフレクション
        self.scheduler.add_job(
            self._monthly_reflection,
            trigger='cron',
            day='last',
            hour=self.config.monthly_reflection_hour,
            minute=0,
            timezone=self.config.timezone
        )
        
    async def process_event(self, event: TradingEvent):
        """イベントドリブンなリフレクション処理"""
        
        # トリガー条件チェック
        triggered_tasks = self.trigger.should_trigger(event)
        
        # 優先度に基づいて実行
        for task in sorted(triggered_tasks, key=lambda t: t.priority, reverse=True):
            if task.priority == Priority.CRITICAL:
                # 即時実行
                await self.executor.execute_reflection(task)
            else:
                # キューに追加
                await self.executor.queue_reflection(task)
```

## 5. リフレクションの深さ制御

### 5.1 ReflectionDepth

```python
class ReflectionDepth:
    """リフレクションの深さレベル"""
    
    SHALLOW = {
        "analysis_scope": "recent_trades",
        "lookback_period": "1_day",
        "metrics_detail": "summary",
        "learning_update": "incremental"
    }
    
    MEDIUM = {
        "analysis_scope": "recent_patterns",
        "lookback_period": "1_week",
        "metrics_detail": "detailed",
        "learning_update": "pattern_based"
    }
    
    DEEP = {
        "analysis_scope": "comprehensive",
        "lookback_period": "1_month",
        "metrics_detail": "granular",
        "learning_update": "strategy_revision"
    }
    
    COMPREHENSIVE = {
        "analysis_scope": "full_history",
        "lookback_period": "all_available",
        "metrics_detail": "exhaustive",
        "learning_update": "system_overhaul"
    }
```

### 5.2 深さの自動調整

```python
class ReflectionDepthController:
    """リフレクションの深さを動的に調整"""
    
    def determine_depth(
        self, 
        task: ReflectionTask, 
        system_state: SystemState
    ) -> Dict[str, Any]:
        """タスクとシステム状態に基づいて深さを決定"""
        
        # パフォーマンスが悪い時は深い分析
        if system_state.recent_performance < self.config.performance_threshold:
            return ReflectionDepth.DEEP
            
        # 重大なイベント後は包括的分析
        if task.priority == Priority.CRITICAL:
            return ReflectionDepth.COMPREHENSIVE
            
        # 定期的な振り返りは中程度
        if task.level in [ReflectionLevel.WEEKLY, ReflectionLevel.MONTHLY]:
            return ReflectionDepth.MEDIUM
            
        # デフォルトは浅い分析
        return ReflectionDepth.SHALLOW
```

## 6. 実装例

### 6.1 バックテストエンジンへの統合

```python
class BacktestEngine:
    """リフレクション機能を統合したバックテストエンジン"""
    
    def __init__(self, config: BacktestConfig):
        # 既存の初期化
        super().__init__(config)
        
        # リフレクション機能の追加
        self.reflection_scheduler = ReflectionScheduler(config.reflection_config)
        self.reflection_trigger = ReflectionTrigger(config.trigger_config)
        
    async def run(self) -> BacktestResult:
        """リフレクション機能を含むバックテスト実行"""
        
        while self.time_manager.has_next():
            current_date = self.time_manager.current_date
            
            # 通常の取引処理
            decision = await self._make_trading_decision(current_date)
            
            if decision.action != TradeAction.HOLD:
                trade_result = await self._execute_trade(decision)
                
                # 取引実行イベントでリフレクショントリガー
                trade_event = TradeExecutedEvent(
                    timestamp=current_date,
                    decision=decision,
                    result=trade_result
                )
                await self.reflection_scheduler.process_event(trade_event)
            
            # ポジション更新
            closed_positions = self.position_manager.update_positions(current_date)
            
            # ポジションクローズイベント
            for position in closed_positions:
                close_event = PositionClosedEvent(
                    timestamp=current_date,
                    position=position,
                    pnl=position.realized_pnl
                )
                await self.reflection_scheduler.process_event(close_event)
            
            # 日次終了時の定期チェック
            eod_event = EndOfDayEvent(
                timestamp=current_date,
                daily_metrics=self._calculate_daily_metrics()
            )
            await self.reflection_scheduler.process_event(eod_event)
            
            # 次の日へ
            self.time_manager.next()
            
        return self._calculate_results()
```

### 6.2 設定例

```yaml
reflection_config:
  triggers:
    event_based:
      enabled: true
      immediate_reflection_on_trade: true
      reflection_on_position_close: true
      
    time_based:
      daily:
        enabled: true
        time: "17:00"  # 市場クローズ後
        timezone: "America/New_York"
      weekly:
        enabled: true
        day: "friday"
        time: "18:00"
      monthly:
        enabled: true
        day: "last"
        time: "20:00"
        
    performance_based:
      consecutive_losses_threshold: 3
      max_drawdown_threshold: 0.15  # 15%
      abnormal_return_threshold: 0.05  # 5%
      
    threshold_based:
      trades_per_reflection: 10
      disagreement_threshold: 0.7  # 70%の不一致
      memory_threshold: 0.8  # 80%使用
      
  execution:
    max_concurrent_reflections: 3
    reflection_timeout: 300  # 5分
    retry_on_failure: true
    max_retries: 2
    
  depth_control:
    auto_adjust: true
    min_depth: "shallow"
    max_depth: "comprehensive"
    performance_threshold: -0.05  # -5%
```

## 7. まとめ

このリフレクショントリガー設計により、以下が実現されます：

1. **明確なトリガー条件**：イベント、時間、パフォーマンス、閾値の4つの観点から包括的にトリガー
2. **柔軟な実行制御**：優先度とシステム状態に応じた動的な実行
3. **適切な深さ調整**：状況に応じた分析の深さの自動調整
4. **運用の安定性**：メモリ管理とエラーハンドリングの考慮

これにより、TradingAgents2は継続的に学習し、パフォーマンスを改善していく能力を持つことができます。